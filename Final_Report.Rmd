---
title: "Proteome-wide Screen for RNA-dependent Proteins in Non-Synchronized HeLa cells"
author: "Alisa Kirkin, Sina KÃ¼hnel, Ignacio Lozano Onrubia, Greta Pick"
date: "19/07/2022"
output:
  pdf_document: default
  html_document: default
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Final Report

Idee: vielleicht keine 1-bla Nummerierung, sondern Aufteilung in Phase 1-5 und dann Unterpunkte mit Header2

# 1. Introduction

Cancer, neurological diseases and muscular atrophy - What do these diseases have in common? 
All of them include RNA-binding proteins. RNA-binding proteins (RBP) are proteins that bind RNA and form ribonucleoprotein particles. They are involved in a number of processes like translation, alternative splicing, RNA editing and chemical modification as well as protein modification. RBPs belong to the RNA-dependent proteins (RDP) togehter with RBP-binding proteins. These RBP-binding proteins bind RBPs when they assemble with RNA. Their complex interactions are crucial for cellular functions and therefore it is of importance to identify RDPs.


## 1.1 Summary of experiment
To identify RDPs a proteom-wide screen was conducted with mass-spectometry. HeLa S3 cels in different cell cycle stages were lysed (Fig. 1). The cell lysate was split into a control and an RNase gropup. The RNase group was treated with RNase which causes the degradation of RNase. RBPs can no longer bind to RNA and RBP-binding proteins to RBPs. The control group did not receive any further treatment and therefore all RNA and RDPs interact. The cell lysate was transferred onto a sucrose density gradient. After ultra centrifugation the RNA-protein complexes or proteins alone will end up in one of 25 fractions depending on their molecular weight. A heavy RNA-protein complex will travel further and land in a higher fraction than a single protein from the RNase treatment. This would create a left shift and is expected to happen for RDPs.

![** Generation of Data.**](/Users/gretapick/Desktop/GitHub/2022-topic-03-team-01/Experiment.png)

## 1.2 Goals
The main goal is to automatically identify RDPs on the basis of the fraction shift between control and RNase treatment. 

# 2. Description of the Dataset
The dataset consists of 4765 rows which represent different proteins and 150 columns. Those include 3 replica for each of the 25 fractions for control and RNase treatment (3 x 25 x 2 = 150 columns). For every protein the protein amount in a certain fraction is given in arbitrary units.


# 3. Data Clean Up and Normalization 
Clean Up of the raw data is needed for the following analysis. 
First we split our dataset into two dataframes containing only the control and RNase group. Those were split further into three subtables representing the three reps. A protein was deleted from control and RNase when it had no counts in at least one rep. Eight proteins were deleted, becuase they had at least one all zero row in one rep.

## 3.1 Normalization 
Goal of the normalization is to make the three different reps more similar by applying statistical and mathematical functions.

a) Repwise Normalization 

![**Steps of Normalization.**](/Users/gretapick/Desktop/GitHub/2022-topic-03-team-01/Normalization.png)

For simpler calculation we created subtables seperately for control and RNase containing only one fraction with all three reps (for both control and RNase group 50 subtables were created). For every subtable the mean over all the proteins for every rep from one fraction was calculated, creating 3 mean values in for each of the 50 subtables. 
The function *smallest diff* was created to find the two reps for every individual fraction with the smallest difference of their mean values. The mean value of these two reps over all the proteins from one fraction was determined. The normalization factors for every fraction for each rep was calculated by dividing the mean from the most similar two reps by the individual means of one fraction for each rep (for each of the 50 subtables containing one fraction with three reps, three normalization factors were determined). By multiplying all the values of one fraction of one rep with its individual normalization factor, we received the normalized values for all reps and for both control and RNase group.
When comparing the unnormed values with the normalized values by summing up all the proteins of all fraction for each rap, it is noticably how the reps have been statistically adjusted. 
![**Barplot before and after Normalization of Control.**](/Users/gretapick/Desktop/GitHub/2022-topic-03-team-01/Normalization_ctrl.png)

![**Barplot before and after Normalization of RNAse.**](/Users/gretapick/Desktop/GitHub/2022-topic-03-team-01/Normalization_rnase.png)

b) Fraction-wise Normalization - Scaling
After creating the vectors with the normed values for each fraction, we were ready to scale our data. We created a for loop for each sample which first sums up the values of each fraction and sets this sum to 100. We then calculated the proportion for each protein amount in comparison to the scaled sum of the whole row. This gave us values of protein amount between 1 and 100 and a sum of 100 for the sum of a protein over all fractions. This facilitates the comparison of our values between the reps.

## 3.2 Reproducibility
The three reps for control and RNAse group were adjusted during normalization. Nontheless, it is possible that they differ too much in order to be used in further analysis. Therefore we examined the reproducibility of the reps with correlation. First the normalized data was transformed so that the columns consist of proteins and rows of the different protein amounts in each fraction. We created the function *low.cor* that first calculates the pearson correlation over all fractions of each protein of two reps. It returns only the column numbers of proteins which reps have a correlation coefficient beneath 0.7. By applying *low.cor* six times (rep1 & rep2, rep1 & rep3, rep2 & rep3 for control and RNase) we could create a dataframe that contains only proteins with low correlation and includes how often a protein did not correlate well. 
Proteins that have a low correlation coefficient two or three times (three times meaning that no rep correlates well) are deleted.

## 3.3 Smoothing the Curve
To smoothen the curve, we created to for loops. The first loop goes through each row so that the second for loop is applied to each protein. The second loop takes fraction i and calculates the mean of fraction i, i-1 and i+1. This mean will then replace the original value of the protein amount in fraction i. Since there is no fraction before fraction 1 and no fraction after fraction 25, the second loop is only applied to fraction 2-24 for every protein of each rep. 
This step would be essential before fitting the curve to a Gaussian curve for certain proteins. In Figure 3 and 4 the result of smoothing can be seen for the protein AHNK_HUMAN. Individual fractions are corrected and the curve looks more familiar to the Gaussian curve.
![**AHNK_HUMAN before Smoothing.**](/Users/gretapick/Desktop/GitHub/2022-topic-03-team-01/before_smoothing.png)
![**AHNK_HUMAN after Smoothing.**](/Users/gretapick/Desktop/GitHub/2022-topic-03-team-01/after_smoothing.png)

# 4. Maxima  


## 4.2 Identification of global Maxima


## 5.1 Clustering with K-means 
K-means clustering can be used to identify clusters in a data set. In our project we can use it to identify proteins with similar characteristics in their shifts between control and RNase. When using k-means one can set the number of clusters (k). We chose different cluster amounts from two to six. 
To determine which amount of clusters is the best, we used the silhouette and elbow method. The silhouette method calculates the distance of every point to its own and the neighbouring cluster (smallest distance of point i to a point that is not a member of its own cluster). Every point of them abtains a silhouette value between -1 and 1. 1 meaning that the point fits perfectly into its cluster and -1 meaning that it would be more appropriate to place it in a neighbouring cluster. By changing the amounts of clusters, the overall mean of the silhouette value of all points change. The higher this mean is, the more accurate the clustering works. 
The elbow method calculates the Within-Cluster Sum of Squared Errors (WSS) and for different values of k. You have to chose the k for which the WSS first starts to diminish.
For our proteins the highest mean silhouette value is 0.5255658 for k=5.

![**K-means elbow plot .**](/Users/gretapick/Desktop/GitHub/2022-topic-03-team-01/Kmeans_elbow.png)
##5.2 Ttest to compute pvalues

Before coding the actual function to compute our ttest, we firstly created two empty vectors. One to put the pvalues in and one for the significant proteins. Afterwards we created a for loop that firstly creates a vector each for contol and RNase that contains the peaks of each protein. 
As we encountered some problems with essentially constant values we used an if function to set the pvalue for proteins, which either have a duplicate in the control or rnase group, to 1. We set this value to 1 as this shows that there is absolutely no difference between the values which indicates that there cannot be a significant shift. This did sort out 78 proteins containing constant values and therefore we were then able to compute the two-sided ttest for all other proteins that differ in the amount of the six replicates. The computed pvalue was then adjusted using the method of Benjamini, Hochberg and Yekutiel to decrease the false discovery rate This left us with an amount of 1921 proteins that did show an significant shift.










```{r pressure, echo=FALSE}

```


